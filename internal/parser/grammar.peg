{
package parser

// NB: including all the imports make the parser generator run a bit more quickly.
import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"

	"github.com/mdhender/ottomap/domain"
	"github.com/mdhender/ottomap/internal/compass"
	"github.com/mdhender/ottomap/internal/direction"
	"github.com/mdhender/ottomap/internal/edges"
	"github.com/mdhender/ottomap/internal/items"
	"github.com/mdhender/ottomap/internal/resources"
	"github.com/mdhender/ottomap/internal/unit_movement"
	"github.com/mdhender/ottomap/internal/winds"
)

type Date_t struct {
    Year  int
    Month int
    Day   int
}

func (d Date_t) IsZero() bool {
    return d == Date_t{}
}

type CrowsNestObservation_t struct {
    Point   compass.Point_e
    Terrain string
}

type TurnInfo_t struct {
    CurrentTurn Date_t
    NextTurn    Date_t
}

func bdup(src []byte) []byte {
    dst := make([]byte, len(src))
    copy(dst, src)
    return dst
}

func toAnySlice(v any) []any {
    if v == nil {
        return nil
    }
    return v.([]any)
}

}

Noop <- EOF {
    return true, nil
}

CrowsNestObservation <- cs:CROWSIGHTING SP "-" SP cp:COMPASSPOINT EOF{
    return CrowsNestObservation_t{
        Point: cp.(compass.Point_e),
        Terrain: cs.(string),
    }, nil
}

EdgeType <- "Ford" {
    return edges.Ford, nil
} / "Pass" {
    return edges.Pass, nil
} / "River" {
    return edges.River, nil
} / "Stone Road" {
    return edges.StoneRoad, nil
}

FleetMovement <- ws:WINDSTRENGTH SP d:DIRECTION SP "Fleet Movement:" _ results:ToEOL EOF {
    mt := Movement_t{Type: unit_movement.Fleet}
    mt.Winds.Strength = ws.(winds.Strength_e)
    mt.Winds.From = d.(direction.Direction_e)
    if results != nil {
        mt.Text = bdup(results.([]byte))
    }
    return mt, nil
}

Location <- ("Courier" / "Element" / "Fleet" / "Garrison" / "Tribe") SP u:UNIT_ID "," SP "," SP "Current Hex =" SP ch:COORDS "," SP "(Previous Hex =" SP ph:COORDS ")" _ EOF {
    return Location_t {
        UnitId:      u.(UnitId_t),
        CurrentHex:  ch.(string),
        PreviousHex: ph.(string),
    }, nil
}

ObviousNeighboringTerrainCode <- "Lcm" {
    return domain.TLowConiferMountains, nil
} / "LJm" {
    return domain.TLowJungleMountains, nil
} / "L" {
    return domain.TLake, nil
} / "O" {
    return domain.TOcean, nil
}

ProhibitedBy <- "Lake" {
    return domain.TLake, nil
} / "Ocean" {
    return domain.TOcean, nil
}

ScoutMovement <- "Scout" SP no:[1-8] ":" _ results:ToEOL EOF {
    mt := Movement_t{Type: unit_movement.Scouts}
    switch v := no.(type) {
    case []uint8:
        if len(v) != 1 {
            return nil, fmt.Errorf("invalid scout number")
        }
        mt.ScoutNo = int(v[0] - '0')
    default:
        panic(fmt.Errorf("scoutMovement: unknown type %T", v))
    }
    if results != nil {
        mt.Text = bdup(results.([]byte))
    }
    return mt, nil
}

SpaceDirection <- SP d:DIRECTION {
    return d, nil
}

SpaceUnitID <- SP u:UNIT_ID {
    return u, nil
}

StatusLine <- u:UNIT_ID SP "Status:" _ results:ToEOL EOF {
    mt := Movement_t{
        Type: unit_movement.Status,
        UnitId: u.(UnitId_t),
    }
    if results != nil {
        mt.Text = bdup(results.([]byte))
    }
    return mt, nil
}

Step <- d:DIRECTION "-" t:TERRAIN_CODE EOF {
    return DirectionTerrain_t{
        Direction: d.(direction.Direction_e),
        Terrain:   t.(domain.Terrain),
    }, nil
} / [Cc] "an't Move on" SP t:ProhibitedBy SP "to" SP d:DIRECTION SP "of HEX" EOF {
    return &ProhibitedFrom_t{
        Direction: d.(direction.Direction_e),
        Terrain:   t.(domain.Terrain),
    }, nil
} / "Group did not return" EOF {
    return DidNotReturn_t{}, nil
} / "Find" SP r:RESOURCE EOF {
    return r, nil
} / "Find" SP n:NUMBER SP i:ITEMS EOF {
    return RandomEncounter_t{
        Quantity: n.(int),
        Item :    i.(items.Item_e),
    }, nil
} / [Nn] "o Ford on River to" SP d:DIRECTION SP "of HEX" EOF {
    return &BlockedByEdge_t{
        Direction: d.(direction.Direction_e),
        Edge:      edges.River,
    }, nil
} / "No groups found" EOF {
    return NoGroupsFound_t{}, nil
} / "No River Adjacent to Hex to" SP DIRECTION SP "of HEX" {
    return FoundNothing_t{}, nil
} / [Nn] "ot enough M.P's to move to" SP d:DIRECTION SP "into" SP t:TERRAIN EOF {
    return &Exhausted_t{
        Direction: d.(direction.Direction_e),
        Terrain:   t.(domain.Terrain),
    }, nil
} / [Nn] "othing of interest found" EOF {
    return FoundNothing_t{}, nil
} / "Patrolled and found" SP u:UNIT_ID sui:SpaceUnitID* EOF {
    found := []FoundUnit_t{{Id: u.(UnitId_t)}}
    for _, su := range toAnySlice(sui) {
        switch v := su.(type) {
        case UnitId_t:
            found = append(found, FoundUnit_t{Id: v})
        default:
            panic(fmt.Errorf("unexpected type %T", v))
        }
    }
    return found, nil
} / t:ObviousNeighboringTerrainCode SP+ d:DIRECTION sdi:SpaceDirection* EOF {
    kind := t.(domain.Terrain)
    neighbors := []*Neighbor_t{{
        Direction: d.(direction.Direction_e),
        Terrain:   kind,
    }}
    for _, sd := range toAnySlice(sdi) {
        switch v := sd.(type) {
        case direction.Direction_e:
            neighbors = append(neighbors, &Neighbor_t{Direction: v, Terrain: kind})
        default:
            panic(fmt.Errorf("unexpected type %T", v))
        }
    }
    return neighbors, nil
} / et:EdgeType SP d:DIRECTION edi:SpaceDirection* EOF {
    kind := et.(edges.Edge_e)
    edges := []*Edge_t{&Edge_t{Direction: d.(direction.Direction_e), Edge: kind}}
    for _, ed := range toAnySlice(edi) {
        switch v := ed.(type) {
        case direction.Direction_e:
            edges = append(edges, &Edge_t{Direction: v, Edge: kind})
        default:
            panic(fmt.Errorf("unexpected type %T", v))
        }
    }
    return edges, nil
} / n:NUMBER SP i:ITEM EOF {
    return RandomEncounter_t{
        Quantity: n.(int),
        Item:     i.(items.Item_e),
    }, nil
} / u:UNIT_ID sui:SpaceUnitID* EOF {
    found := []FoundUnit_t{{Id: u.(UnitId_t)}}
    for _, su := range toAnySlice(sui) {
        switch v := su.(type) {
        case UnitId_t:
            found = append(found, FoundUnit_t{Id: v})
        default:
            panic(fmt.Errorf("unexpected type %T", v))
        }
    }
    return found, nil
} / r:RESOURCE EOF {
    return r, nil
} / d:DIRECTION EOF {
    return d, nil
} / t:TERRAIN EOF {
    return t, nil
}

TribeFollows <- "Tribe Follows" SP u:UNIT_ID _ EOF {
    mt := Movement_t{Type: unit_movement.Follows, Follows: u.(UnitId_t)}
    return mt, nil
}

TribeGoesTo <- "Tribe Goes to" SP h:COORDS _ EOF {
    mt := Movement_t{Type: unit_movement.GoesTo, GoesTo: h.(string)}
    return mt, nil
}

TribeMovement <- "Tribe Movement:" _ results:ToEOL EOF {
    mt := Movement_t{Type: unit_movement.Tribe}
    if results != nil {
        mt.Text = bdup(results.([]byte))
    }
    return mt, nil
}

TurnInfo <- cd:CurrentTurn "," SP TurnSeason "," SP TurnWeather nt:NextTurn? _ EOF {
    if nt != nil {
        return TurnInfo_t{
            CurrentTurn: cd.(Date_t),
            NextTurn: nt.(Date_t),
        }, nil
    }

    return TurnInfo_t{
        CurrentTurn: cd.(Date_t),
    }, nil
}

CurrentTurn <- "Current Turn" _ cd:YearMonth _ "(#" DIGIT+ ")" {
    return cd, nil
}

NextTurn <- SP "Next Turn" _ nd:YearMonth _ "(#" DIGIT+ ")," _ ReportDate {
    return nd, nil
}

ReportDate <- DIGIT DIGIT? "/" DIGIT DIGIT? "/" DIGIT DIGIT DIGIT DIGIT {
    //log.Printf("reportDate %q\n", c.text)
    return c.text, nil
}

ToEOL <- .* EOF {
    return c.text, nil
}

TurnSeason <- [A-Z][A-Za-z]+ {
    //log.Printf("turnSeason %q\n", c.text)
    return c.text, nil
}

TurnWeather <- [A-Z][A-Za-z]+ {
    //log.Printf("turnWeather %q\n", c.text)
    return c.text, nil
}

YearMonth <- y:YEAR "-" m:MONTH {
    return Date_t {
        Year:  y.(int),
        Month: m.(int),
    }, nil
}

COMPASSPOINT <- "NE/NE" {
    return compass.NorthEast, nil
} / "NE/SE" {
    return compass.East, nil
} / "NW/NW" {
    return compass.NorthWest, nil
} / "N/NE" {
    return compass.NorthNorthEast, nil
} / "N/NW" {
    return compass.NorthNorthWest, nil
} / "N/N" {
    return compass.North, nil
} / "SE/SE" {
    return compass.SouthEast, nil
} / "SW/NW" {
    return compass.West, nil
} / "SW/SW" {
    return compass.SouthWest, nil
} / "S/SE" {
    return compass.SouthSouthEast, nil
} / "S/SW" {
    return compass.SouthSouthWest, nil
} / "S/S" {
    return compass.South, nil
}

COORDS <- "N/A" {
    return "N/A", nil
} / "##" SP DIGIT DIGIT DIGIT DIGIT {
    return string(c.text), nil
} / LETTER LETTER SP DIGIT DIGIT DIGIT DIGIT {
    return string(c.text), nil
}

CROWSIGHTING <- "Sight Land" {
    return "Land", nil
} / "Sight Water" {
    return "Water", nil
}

DIRECTION <- "NE" {
    return direction.NorthEast, nil
} / "SE" {
    return direction.SouthEast, nil
} / "SW" {
    return direction.SouthWest, nil
} / "NW" {
    return direction.NorthWest, nil
} / "N" {
    return direction.North, nil
} / "S" {
    return direction.South, nil
}

ITEM <- "adze"i         { return items.Adze, nil
} /		"arbalest"i     { return items.Arbalest, nil
} /		"arrows"i       { return items.Arrows, nil
} /		"axes"i         { return items.Axes, nil
} /		"backpack"i     { return items.Backpack, nil
} /		"ballistae"i    { return items.Ballistae, nil
} /		"bark"i         { return items.Bark, nil
} /		"barrel"i       { return items.Barrel, nil
} /		"bladder"i      { return items.Bladder, nil
} /		"blubber"i      { return items.Blubber, nil
} /		"boat"i         { return items.Boat, nil
} /		"bonearmour"i   { return items.BoneArmour, nil
} /		"bones"i        { return items.Bones, nil
} /		"bows"i         { return items.Bows, nil
} /		"bread"i        { return items.Bread, nil
} /		"breastplate"i  { return items.Breastplate, nil
} /		"candle"i       { return items.Candle, nil
} /		"canoes"i       { return items.Canoes, nil
} /		"carpets"i      { return items.Carpets, nil
} /		"catapult"i     { return items.Catapult, nil
} /		"cattle"i       { return items.Cattle, nil
} /		"cauldrons"i    { return items.Cauldrons, nil
} /		"chain"i        { return items.Chain, nil
} /		"china"i        { return items.China, nil
} /		"clay"i         { return items.Clay, nil
} /		"cloth"i        { return items.Cloth, nil
} /		"clubs"i        { return items.Clubs, nil
} /		"coal"i         { return items.Coal, nil
} /		"coffee"i       { return items.Coffee, nil
} /		"coins"i        { return items.Coins, nil
} /		"cotton"i       { return items.Cotton, nil
} /		"cuirass"i      { return items.Cuirass, nil
} /		"cuirboilli"i   { return items.Cuirboilli, nil
} /		"diamond"i      { return items.Diamond, nil
} /		"diamonds"i     { return items.Diamonds, nil
} /		"drum"i         { return items.Drum, nil
} /		"elephant"i     { return items.Elephant, nil
} /		"falchion"i     { return items.Falchion, nil
} /		"fish"i         { return items.Fish, nil
} /		"flax"i         { return items.Flax, nil
} /		"flour"i        { return items.Flour, nil
} /		"flute"i        { return items.Flute, nil
} /		"fodder"i       { return items.Fodder, nil
} /		"frame"i        { return items.Frame, nil
} /		"frankincense"i { return items.Frankincense, nil
} /		"fur"i          { return items.Fur, nil
} /		"glasspipe"i    { return items.Glasspipe, nil
} /		"goats"i        { return items.Goats, nil
} /		"gold"i         { return items.Gold, nil
} /		"grain"i        { return items.Grain, nil
} /		"grape"i        { return items.Grape, nil
} /		"gut"i          { return items.Gut, nil
} /		"hbow"i         { return items.HBow, nil
} /		"harp"i         { return items.Harp, nil
} /		"haube"i        { return items.Haube, nil
} /		"heaters"i      { return items.Heaters, nil
} /		"helm"i         { return items.Helm, nil
} /		"herbs"i        { return items.Herbs, nil
} /		"hive"i         { return items.Hive, nil
} /		"hoe"i          { return items.Hoe, nil
} /		"honey"i        { return items.Honey, nil
} /		"hood"i         { return items.Hood, nil
} /		"horn"i         { return items.Horn, nil
} /		"horses"i       { return items.Horses, nil
} /		"jade"i         { return items.Jade, nil
} /		"jerkin"i       { return items.Jerkin, nil
} /		"kayak"i        { return items.Kayak, nil
} /		"ladder"i       { return items.Ladder, nil
} /		"leather"i      { return items.Leather, nil
} /		"logs"i         { return items.Logs, nil
} /		"lute"i         { return items.Lute, nil
} /		"mace"i         { return items.Mace, nil
} /		"mattock"i      { return items.Mattock, nil
} /		"metal"i        { return items.Metal, nil
} /		"millstone"i    { return items.MillStone, nil
} /		"musk"i         { return items.Musk, nil
} /		"net"i          { return items.Net, nil
} /		"oar"i          { return items.Oar, nil
} /		"oil"i          { return items.Oil, nil
} /		"olives"i       { return items.Olives, nil
} /		"opium"i        { return items.Opium, nil
} /		"ores"i         { return items.Ores, nil
} /		"paddle"i       { return items.Paddle, nil
} /		"palanquin"i    { return items.Palanquin, nil
} /		"parchment"i    { return items.Parchment, nil
} /		"pavis"i        { return items.Pavis, nil
} /		"pearls"i       { return items.Pearls, nil
} /		"pellets"i      { return items.Pellets, nil
} /		"people"i       { return items.People, nil
} /		"pewter"i       { return items.Pewter, nil
} /		"picks"i        { return items.Picks, nil
} /		"plows"i        { return items.Plows, nil
} /		"provisions"i   { return items.Provisions, nil
} /		"quarrel"i      { return items.Quarrel, nil
} /		"rake"i         { return items.Rake, nil
} /		"ram"i          { return items.Ram, nil
} /		"ramp"i         { return items.Ramp, nil
} /		"ring"i         { return items.Ring, nil
} /		"rope"i         { return items.Rope, nil
} /		"rug"i          { return items.Rug, nil
} /		"saddle"i       { return items.Saddle, nil
} /		"saddlebag"i    { return items.Saddlebag, nil
} /		"salt"i         { return items.Salt, nil
} /		"sand"i         { return items.Sand, nil
} /		"scale"i        { return items.Scale, nil
} /		"sculpture"i    { return items.Sculpture, nil
} /		"scutum"i       { return items.Scutum, nil
} /		"scythe"i       { return items.Scythe, nil
} /		"shackle"i      { return items.Shackle, nil
} /		"shaft"i        { return items.Shaft, nil
} /		"shield"i       { return items.Shield, nil
} /		"shovel"i       { return items.Shovel, nil
} /		"silk"i         { return items.Silk, nil
} /		"silver"i       { return items.Silver, nil
} /		"skin"i         { return items.Skin, nil
} /		"slaves"i       { return items.Slaves, nil
} /		"slings"i       { return items.Slings, nil
} /		"snare"i        { return items.Snare, nil
} /		"spear"i        { return items.Spear, nil
} /		"spetum"i       { return items.Spetum, nil
} /		"spice"i        { return items.Spice, nil
} /		"statue"i       { return items.Statue, nil
} /		"stave"i        { return items.Stave, nil
} /		"stones"i       { return items.Stones, nil
} /		"string"i       { return items.String, nil
} /		"sugar"i        { return items.Sugar, nil
} /		"sword"i        { return items.Sword, nil
} /		"tapestries"i   { return items.Tapestries, nil
} /		"tea"i          { return items.Tea, nil
} /		"tobacco"i      { return items.Tobacco, nil
} /		"trap"i         { return items.Trap, nil
} /		"trews"i        { return items.Trews, nil
} /		"trinket"i      { return items.Trinket, nil
} /		"trumpet"i      { return items.Trumpet, nil
} /		"urn"i          { return items.Urn, nil
} /		"wagons"i       { return items.Wagons, nil
} /		"wax"i          { return items.Wax, nil}

MONTH <- DIGIT DIGIT? {
    n, _ := strconv.Atoi(string(c.text))
    return int(n), nil
}

NUMBER <- [0-9]+ {
    n, _ := strconv.Atoi(string(c.text))
    return int(n), nil
}

RESOURCE <- "Coal" {
    return resources.Coal, nil
} / "Copper Ore" {
    return resources.CopperOre, nil
} / "Diamond" {
    return resources.Diamond, nil
} / "Frankincense" {
    return resources.Frankincense, nil
} / "Gold" {
    return resources.Gold, nil
} / "Iron Ore" {
    return resources.IronOre, nil
} / "Jade" {
    return resources.Jade, nil
} / "Kaolin" {
    return resources.Kaolin, nil
} / "Lead Ore" {
    return resources.LeadOre, nil
} / "Limestone" {
    return resources.Limestone, nil
} / "Nickel Ore" {
    return resources.NickelOre, nil
} / "Pearls" {
    return resources.Pearls, nil
} / "Pyrite" {
    return resources.Pyrite, nil
} / "Rubies" {
    return resources.Rubies, nil
} / "Salt" {
    return resources.Salt, nil
} / "Silver" {
    return resources.Silver, nil
} / "Sulphur" {
    return resources.Sulphur, nil
} / "Tin Ore" {
    return resources.TinOre, nil
} / "Vanadium Ore" {
    return resources.VanadiumOre, nil
} / "Zinc Ore" {
    return resources.ZincOre, nil
}

TERRAIN <- "ALPS" {
    return domain.TAlps, nil
} / "ARID TUNDRA" {
    return domain.TAridTundra, nil
} / "ARID" {
    return domain.TAridHills, nil
} / "BRUSH HILLS" {
    return domain.TBrushHills, nil
} / "BRUSH" {
    return domain.TBrush, nil
} / "CONIFER HILLS" {
    return domain.TConiferHills, nil
} / "DECIDUOUS FOREST" {
    return domain.TDeciduous, nil
} / "DECIDUOUS HILLS" {
    return domain.TDeciduousHills, nil
} / "DECIDUOUS" {
    return domain.TDeciduous, nil
} / "DESERT" {
    return domain.TDesert, nil
} / "GRASSY HILLS PLATEAU" {
    return domain.TGrassyHillsPlateau, nil
} / "GRASSY HILLS" {
    return domain.TGrassyHills, nil
} / "JUNGLE HILLS" {
    return domain.TJungleHills, nil
} / "JUNGLE" {
    return domain.TJungle, nil
} / "LAKE" {
    return domain.TLake, nil
} / "LOW ARID MOUNTAINS" {
    return domain.TLowAridMountains, nil
} / "LOW CONIFER MOUNTAINS" {
    return domain.TLowConiferMountains, nil
} / "LOW JUNGLE MOUNTAINS" {
    return domain.TLowJungleMountains, nil
} / "LOW SNOWY MOUNTAINS" {
    return domain.TLowSnowyMountains, nil
} / "LOW VOLCANIC MOUNTAINS" {
    return domain.TLowVolcanicMountains, nil
} / "OCEAN" {
    return domain.TOcean, nil
} / "POLAR ICE" {
    return domain.TPolarIce, nil
} / "PRAIRIE PLATEAU" {
    return domain.TPrairiePlateau, nil
} / "PRAIRIE" {
    return domain.TPrairie, nil
} / "ROCKY HILLS" {
    return domain.TRockyHills, nil
} / "SNOWY HILLS" {
    return domain.TSnowyHills, nil
} / "SWAMP" {
    return domain.TSwamp, nil
} / "TUNDRA" {
    return domain.TTundra, nil
}

TERRAIN_CODE <- "ALPS" {    return domain.TAlps, nil
} / "GHP" { return domain.TGrassyHillsPlateau, nil
} / "HSM" { return domain.TAridTundra, nil
} / "LAM" { return domain.TLowAridMountains, nil
} / "LCM" { return domain.TLowConiferMountains, nil
} / "LJM" { return domain.TLowJungleMountains, nil
} / "LSM" { return domain.TLowSnowyMountains, nil
} / "LVM" { return domain.TLowVolcanicMountains, nil
} / "PPR" { return domain.TPrairiePlateau, nil
} / "AH" { return domain.TAridHills, nil
} / "AR" { return domain.TAridTundra, nil
} / "BH" { return domain.TBrushHills, nil
} / "BR" { return domain.TBrush, nil
} / "CH" { return domain.TConiferHills, nil
} / "DE" { return domain.TDesert, nil
} / "DH" { return domain.TDeciduousHills, nil
} / "GH" { return domain.TGrassyHills, nil
} / "JG" { return domain.TJungle, nil
} / "JH" { return domain.TJungleHills, nil
} / "PI" { return domain.TPolarIce, nil
} / "PR" { return domain.TPrairie, nil
} / "RH" { return domain.TRockyHills, nil
} / "SH" { return domain.TSnowyHills, nil
} / "SW" { return domain.TSwamp, nil
} / "TU" { return domain.TTundra, nil
} / "D" { return domain.TDeciduous, nil
} / "L" { return domain.TLake, nil
} / "O" { return domain.TOcean, nil
}

UNIT_ID <- DIGIT DIGIT DIGIT DIGIT ([cefg] [1-9])? {
    return UnitId_t(c.text), nil
}

WINDSTRENGTH <- "CALM" {
    return winds.Calm, nil
} / "MILD" {
    return winds.Mild, nil
} / "STRONG" {
    return winds.Strong, nil
} / "GALE" {
    return winds.Gale, nil
}

YEAR <- DIGIT DIGIT DIGIT DIGIT? {
    n, _ := strconv.Atoi(string(c.text))
    return int(n), nil
}


EOF    = !.
DIGIT  = [0-9]
LETTER = [A-Z]
SP     = [ \t]+
_      = [ \t]*
